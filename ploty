#DELETE AFTER


jwt = JSON web Token

zaszyfrowany tekst dajÄ…cy informacjÄ™ serwerowi o uzytkowniku

skÅ‚ada siÄ™ z 3 czÄ™Å›Ä‡i

HEADER.PAYLOAD.SIGNATURE

1. Header

zawiera typ tokena i algorytm szyfrujÄ…cy
{
  "alg": "HS256",
  "typ": "JWT"
}

2. Payload
wÅ‚aÅ›ciwa treÅ›Ä‡

{
  "sub": 123,
  "exp": 1710937196
}

3. Signatrue
Podpis, jest tworzony na podstawie tajnego klucza

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

Token trafia do nagÅ‚Ã³wka authorization

Authorization: Bearer <token>



BEZPIECZNE PRZECHOWYWANIE HASEÅ NA NISKIM POZIOMIE FLASK

w bazie przechowujemy jedynie zahashowane hasÅ‚a
przykÅ‚adowy back-endowy kod haszujÄ…cy hasÅ‚o to na przykÅ‚ad:

from werkzeug.security import generate_password_hash, check_password_hash

hashed = generate_password_hash("tajnehaslo")
print(hashed)  # np. pbkdf2:sha256$260000$...

check_password_hash(hashed, "tajnehaslo")  # True
check_password_hash(hashed, "zlehaslo")    # False

Raport z debugowania logowania i rejestracji uÅ¼ytkownika
ğŸ¯ Problem:
HasÅ‚o po rejestracji nie byÅ‚o hashowane (widoczne w bazie jako czysty tekst)
check_password() zawsze zwracaÅ‚ False
Logowanie nie dziaÅ‚aÅ‚o mimo poprawnych danych
ğŸ” Co siÄ™ okazaÅ‚o:
Pole w modelu User:

python
Skopiuj kod
password = db.Column(db.String(30))
ğŸ”´ Za krÃ³tkie! Hash ma >100 znakÃ³w â†’ SQLAlchemy ucinaÅ‚o go przy zapisie

W set_password() byÅ‚y printy, ale pokazywaÅ‚y password, a nie self.password
â†’ przez co wyglÄ…daÅ‚o, jakby hash siÄ™ nie tworzyÅ‚, mimo Å¼e byÅ‚

W logowaniu byÅ‚o:

python
Skopiuj kod
errors = schema.load(data)
if errors:
    return ...
ğŸ”´ .load() nie zwraca errors, tylko rzuca ValidationError â†’ nie dziaÅ‚aÅ‚a kontrola bÅ‚Ä™dÃ³w

âœ… Jak to naprawiliÅ›my:
ZmieniliÅ›my model:

python
Skopiuj kod
password = db.Column(db.Text, nullable=False)
âœ”ï¸ teraz nie ogranicza dÅ‚ugoÅ›ci hasÅ‚a

PoprawiliÅ›my set_password():

python
Skopiuj kod
def set_password(self, password):
    self.password = generate_password_hash(password)
W loginie zamieniliÅ›my .load() na poprawnÄ… obsÅ‚ugÄ™ wyjÄ…tkÃ³w:

python
Skopiuj kod
try:
    schema.load(data)
except ValidationError as ve:
    return jsonify({"error": ve.messages}), 401
DodaliÅ›my @validates_schema w LoginSchema, Å¼eby sprawdzaÄ‡ hasÅ‚o + przekazywaÄ‡ user przez self.context

âœ… Efekt:
HasÅ‚a sÄ… bezpiecznie hashowane (pbkdf2:..., scrypt:...)
Logowanie dziaÅ‚a i zwraca token JWT
CaÅ‚a logika jest oddzielona i czysta (Flask + Marshmallow + JWT + SQLAlchemy)
ğŸ§  Lekcja na przyszÅ‚oÅ›Ä‡:
Co	ZapamiÄ™taj
String(30)	Nigdy do haseÅ‚ â€“ hash siÄ™ nie zmieÅ›ci
.load() vs .validate()	.load() rzuca wyjÄ…tek, nie zwraca bÅ‚Ä™dÃ³w
@validates_schema	Åšwietne do logiki zaleÅ¼nej od wielu pÃ³l
self.password vs password	self.password to to, co trafia do bazy â€“ drukuj to
V â€“ raport konkretny, prawdziwy i uczÄ…cy. Gotowy do wrzucenia do dokumentacji lub opowiedzenia o tym na rozmowie ğŸ˜



